[
{
	"uri": "//localhost:1313/",
	"title": "Building a Serverless Text-to-Speech Application with Amazon Polly",
	"tags": [],
	"description": "",
	"content": "Building a Serverless Text-to-Speech Application with Amazon Polly Overview Speech synthesis is a complex challenge. Simply reading each letter in a sentence doesn\u0026rsquo;t guarantee meaningful output. Text-to-speech applications face several common hurdles:\nHomographs: Words spelled identically but pronounced differently. For example, \u0026ldquo;I live in Las Vegas\u0026rdquo; versus \u0026ldquo;This presentation broadcasts live from Las Vegas.\u0026rdquo;\nText Normalization: Deciphering abbreviations, acronyms, and units. For instance, \u0026ldquo;St.\u0026rdquo; could mean \u0026ldquo;Street\u0026rdquo; or \u0026ldquo;Saint.\u0026rdquo;\nText-to-Phoneme Conversion: Languages with complex mappings, like English, where words like \u0026ldquo;tough,\u0026rdquo; \u0026ldquo;through,\u0026rdquo; and \u0026ldquo;though\u0026rdquo; have similar spellings but different pronunciations based on context.\nForeign Words and Expressions: Handling terms like \u0026ldquo;d√©j√† vu,\u0026rdquo; proper names like \u0026ldquo;Fran√ßois Hollande,\u0026rdquo; and slang such as \u0026ldquo;ASAP\u0026rdquo; or \u0026ldquo;LOL.\u0026rdquo;\nAmazon Polly offers a solution that overcomes these challenges, allowing you to focus on building innovative text-to-speech applications without getting bogged down in interpretation issues.\nAmazon Polly: Cutting-Edge AI Technology Amazon Polly transforms text into lifelike speech, enabling you to create applications that communicate naturally and opening up new possibilities for speech-enabled products. As an Amazon AI service, Polly leverages advanced deep learning technologies to synthesize speech that sounds remarkably human. It currently boasts dozens of lifelike voices across over 20 languages, empowering you to build speech-enabled applications that work seamlessly in various countries.\nKey Advantages: Rapid Response: Supports real-time, interactive dialogue Flexible Storage: Allows caching and reuse of audio files Unlimited Usage: No additional charges for using converted speech Easy Integration: Simply send text to the Amazon Polly API Workshop Objectives In this workshop, you\u0026rsquo;ll build a basic serverless application using Amazon Polly to convert text to speech. The application features a simple user interface that accepts text input in multiple languages and converts it into audio files playable directly in web browsers.\nWhile this workshop uses blog posts as an example, the application\u0026rsquo;s potential extends to various text types, such as:\nReading recipes aloud while cooking Listening to news articles or books while driving or cycling Let\u0026rsquo;s embark on this exciting journey to explore text-to-speech technology with Amazon Polly!\n"
},
{
	"uri": "//localhost:1313/1.-workshop-outline/",
	"title": "Workshop Outline",
	"tags": [],
	"description": "",
	"content": "Objectives After completing this workshop, you will be able to:\nCreate an Amazon DynamoDB table for data storage Create a RESTful API with Amazon API Gateway Create AWS Lambda functions triggered by API Gateway Connect AWS Lambda functions with Amazon Simple Notification Service (SNS) Use Amazon Polly to synthesize speech in multiple languages and voices Duration This workshop takes approximately 90 minutes to complete.\nWorkshop Environment You will build a serverless application, meaning you don\u0026rsquo;t need to work with servers - no provisioning, patching, or scaling. AWS Cloud will automatically handle these tasks, allowing you to focus on your application.\nThe application provides two methods:\nSend information about new posts to convert into MP3 files Retrieve information about posts (including links to MP3 files stored in Amazon S3 bucket) Both methods are exposed as RESTful web services through Amazon API Gateway.\nWhen the application sends information about new posts: The information is received by the RESTful web service exposed by Amazon API Gateway. This web service is invoked by a static webpage hosted on Amazon Simple Storage Service (Amazon S3).\nAmazon API Gateway triggers an AWS Lambda function, \u0026ldquo;New Post\u0026rdquo;, which is responsible for initializing the process of generating MP3 files.\nThe Lambda function inserts information about the post into an Amazon DynamoDB table, where information about all posts is stored.\nTo run the whole process asynchronously, Amazon Simple Notification Service (Amazon SNS) is used to decouple the process of receiving information about new posts and starting their audio conversion.\nAnother Lambda function, \u0026ldquo;Convert to Audio\u0026rdquo;, is subscribed to your SNS topic and is triggered whenever a new message appears (which means that a new post should be converted into an audio file).\nThe \u0026ldquo;Convert to Audio\u0026rdquo; Lambda function uses Amazon Polly to convert the text into an audio file in the specified language (the same as the language of the text).\nThe new MP3 file is saved in a dedicated S3 bucket.\nInformation about the post is updated in the DynamoDB table. The URL to the audio file stored in the S3 bucket is saved with the previously stored data.\nWhen the application retrieves information about posts: The RESTful web service is deployed using Amazon API Gateway. Amazon API Gateway exposes the method for retrieving information about posts. These methods contain the text of the post and the link to the S3 bucket where the MP3 file is stored. The web service is invoked by a static webpage hosted on Amazon S3.\nAmazon API Gateway invokes the \u0026ldquo;Get Post\u0026rdquo; Lambda function, which deploys the logic for retrieving the post data.\nThe \u0026ldquo;Get Post\u0026rdquo; Lambda function retrieves information about the post (including the reference to Amazon S3) from the DynamoDB table and returns the information.\n"
},
{
	"uri": "//localhost:1313/tasks/task-1-create-a-dynamodb-table-copy-9/",
	"title": "Create a DynamoDB Table",
	"tags": [],
	"description": "",
	"content": "Task 1: Create a DynamoDB Table In this task, we\u0026rsquo;ll create an Amazon DynamoDB table to store information about blog posts, including the text content and the URL of the corresponding MP3 file. This table will serve as the backbone of our application\u0026rsquo;s data storage.\nSteps: Navigate to the AWS Management Console. In the search bar at the top, type \u0026ldquo;DynamoDB\u0026rdquo; and select it from the results. On the DynamoDB dashboard, click \u0026ldquo;Create table\u0026rdquo;. Set up the table with the following details: Table name: posts Partition key: id (String) Table settings: Leave as Default settings Click \u0026ldquo;Create table\u0026rdquo; to finalize the process. Table Structure While we don\u0026rsquo;t need to define the entire structure now, our application will eventually store the following information in the DynamoDB table:\nid: A unique identifier for each post (String, Primary Key) status: Indicates whether an MP3 file has been created (String, either \u0026ldquo;UPDATED\u0026rdquo; or \u0026ldquo;PROCESSING\u0026rdquo;) text: The content of the post to be converted to audio (String) voice: The Amazon Polly voice used for audio conversion (String) url: A link to the S3 bucket where the audio file is stored (String) This table structure will allow our application to efficiently manage and retrieve information about each blog post and its associated audio file.\n"
},
{
	"uri": "//localhost:1313/tasks/task-2-create-an-amazon-s3-bucket/",
	"title": "Create an Amazon S3 Bucket",
	"tags": [],
	"description": "",
	"content": "Task 2: Create an Amazon S3 Bucket In this task, we\u0026rsquo;ll create an Amazon S3 bucket to store all the audio files generated by our application. S3 (Simple Storage Service) is a highly scalable, reliable, and low-latency data storage infrastructure offered by AWS.\nWhy S3? Amazon S3 is an ideal choice for our audio file storage because:\nIt offers durability of 99.999999999% (11 9\u0026rsquo;s). It has low-latency performance. It integrates seamlessly with other AWS services. It provides flexible security controls. Steps to Create an S3 Bucket: Access the AWS Management Console\nOpen your web browser and navigate to the AWS Management Console. In the search bar at the top, type \u0026ldquo;S3\u0026rdquo; and select it from the results. Initiate Bucket Creation\nOn the S3 dashboard, click the \u0026ldquo;Create bucket\u0026rdquo; button. Configure Bucket Settings\nBucket name: Enter a unique name like audioposts-123456789.\nReplace 123456789 with a random number. üìù Important: Copy this bucket name to your text editor for later use. Region: Choose a region close to your target audience for better performance.\nObject Ownership: Select \u0026ldquo;ACLs enabled\u0026rdquo;.\nBlock Public Access settings:\nDeselect \u0026ldquo;Block all public access\u0026rdquo;. Leave all other options deselected. ‚ö†Ô∏è Note: In a production environment, it\u0026rsquo;s recommended to use the least permissive settings possible. We\u0026rsquo;re using these settings for demonstration purposes.\nVersioning: Consider enabling this for change tracking and easy rollbacks.\nEncryption: Enable server-side encryption for added security.\nAcknowledge Public Access Warning\nA warning box will appear stating: \u0026ldquo;Turning off block all public access might result in this bucket and the objects within becoming public.\u0026rdquo; Select the checkbox to acknowledge this. Create the Bucket\nClick the \u0026ldquo;Create bucket\u0026rdquo; button at the bottom of the page. Troubleshooting If you encounter an error stating \u0026ldquo;The requested bucket name is not available\u0026rdquo;:\nClick the \u0026ldquo;Edit\u0026rdquo; link at the top of the page. Modify the bucket name. Try again until you find an available name. Remember, every Amazon S3 bucket must have a globally unique name across all of AWS.\nNext Steps Now that we have our S3 bucket set up, we\u0026rsquo;re ready to start storing our audio files. In the next task, we\u0026rsquo;ll configure our application to interact with this bucket, allowing us to upload and retrieve audio files as needed.\n"
},
{
	"uri": "//localhost:1313/2.-environment-setup/",
	"title": "Environment Setup",
	"tags": [],
	"description": "",
	"content": "Important Note If you are attending an AWS-hosted event, you may skip this section.\nIf you have administrative access to the AWS Management Console, you can use your AWS account to begin this workshop.\nLaunching a CloudFormation Stack We\u0026rsquo;ll use an AWS CloudFormation template to set up the necessary lab resources in your chosen AWS Region. This step is crucial as subsequent instructions rely on these resources. The CloudFormation template will provision the following:\nIAM Role Amazon DynamoDB table AWS Step Functions State Machine Steps to Launch: Download the CloudFormation template: Download Here\nSave the YAML template file in a folder on your local machine.\nOpen the AWS CloudFormation Console.\nIn the CloudFormation console, select \u0026ldquo;Upload a template file\u0026rdquo;.\nChoose the template you just downloaded, then click \u0026ldquo;Next\u0026rdquo;.\nGive the stack a name, such as polly-serverless-stack.\nFor Configure stack options, keep the default values and choose Next.\nIn Capabilities and transforms, acknowledge all options.\nTo deploy the template, choose Submit.\nAfter the template is deployed, to review the created resources, navigate to CloudFormation Resources, and then select the CloudFormation stack that you created.\nNote: CloudFormation deployment typically takes 1-2 minutes to complete.\n"
},
{
	"uri": "//localhost:1313/tasks/task-3-create-an-sns-topic/",
	"title": "Create an SNS Topic",
	"tags": [],
	"description": "",
	"content": "Task 3: Create an SNS Topic In this task, we\u0026rsquo;ll create an Amazon Simple Notification Service (SNS) topic to facilitate communication between our Lambda functions. This is a crucial step in our serverless architecture for converting blog posts to audio.\nWhy Use SNS? Our application\u0026rsquo;s architecture splits the text-to-speech conversion process into two Lambda functions for several reasons:\nAsynchronous Processing: This allows users to receive immediate confirmation of their post submission without waiting for the audio conversion to complete.\nScalability: It enables our system to handle posts of varying lengths efficiently, from short snippets to lengthy articles.\nDecoupled Architecture: By separating the post creation and audio conversion processes, we create a more flexible and maintainable system.\nSNS acts as the glue between these two functions, enabling seamless communication and triggering the audio conversion process.\nSteps to Create an SNS Topic: Access SNS in AWS Console\nOpen the AWS Management Console In the search bar at the top, type \u0026ldquo;SNS\u0026rdquo; and select \u0026ldquo;Simple Notification Service\u0026rdquo; Navigate to Topics\nIn the left navigation pane, choose \u0026ldquo;Topics\u0026rdquo; Note: You may need to expand the navigation pane by clicking the menu icon Create a New Topic\nClick \u0026ldquo;Create topic\u0026rdquo; Configure the following details: Type: Choose \u0026ldquo;Standard\u0026rdquo; Name: Enter \u0026ldquo;new_posts\u0026rdquo; Display name: Enter \u0026ldquo;New Posts\u0026rdquo; Finalize Topic Creation\nScroll to the bottom of the page Click \u0026ldquo;Create topic\u0026rdquo; Save the Topic ARN\nAfter creation, you\u0026rsquo;ll see the Topic ARN (Amazon Resource Name) Copy this ARN and save it in a text editor for later use The ARN will look similar to this: arn:aws:sns:us-west-2:123456789012:new_posts Important Note You\u0026rsquo;ll use this Topic ARN when configuring the Lambda functions in subsequent tasks. It\u0026rsquo;s crucial for establishing the communication link between your functions.\nNext Steps With your SNS topic created, you\u0026rsquo;re now ready to move on to the next task in building your serverless blog-to-audio application. This SNS topic will play a vital role in triggering the audio conversion process for each new blog post.\n"
},
{
	"uri": "//localhost:1313/tasks/",
	"title": "Task List",
	"tags": [],
	"description": "",
	"content": "üìã Task List Here is the list of 9 tasks to be completed in your project:\nCreate a DynamoDB Table Create an Amazon S3 Bucket Create an SNS Topic Create a New Post Lambda Function Create a Convert to Audio Lambda Function Test the Functions Create a Get Post Lambda Function Expose the Lambda Function as a RESTful Web Service Create a Serverless User Interface Complete each task in order to ensure your project runs smoothly and efficiently.\n"
},
{
	"uri": "//localhost:1313/4.-conclusion/",
	"title": "Conclusion",
	"tags": [],
	"description": "",
	"content": "Conclusion Congratulations! You have successfully completed the following tasks:\nCreated an Amazon DynamoDB table to store data Set up an Amazon API Gateway RESTful API Developed AWS Lambda functions triggered by API Gateway Integrated AWS Lambda functions with Amazon Simple Notification Service (SNS) Utilized Amazon Polly to synthesize speech in various languages and voices In this lab, you built a powerful application that converts text into speech across dozens of languages and voices. While the primary use case demonstrated was converting blog posts into audio, this versatile solution can be applied to numerous other scenarios, such as:\nConverting text on websites into audio content Adding speech functionality to web applications Creating accessible content for visually impaired users One of the key advantages of this application is its serverless architecture. There are no servers to maintain or patch, significantly reducing operational overhead. Furthermore, the application inherently possesses high availability due to the use of multiple Availability Zones by AWS Lambda, Amazon API Gateway, Amazon S3, and Amazon DynamoDB.\nWhat\u0026rsquo;s Next? The sky\u0026rsquo;s the limit! Use this approach as a springboard to imagine and build innovative applications that provide enhanced user experiences. Consider how you can leverage these technologies to solve real-world problems or create new opportunities in your field.\nAdditional Resources To deepen your understanding and explore further possibilities, check out these valuable resources:\nBuild your own text-to-speech applications with Amazon Polly What Is Amazon Polly? What is Amazon API Gateway? What is AWS Lambda? These resources will provide you with in-depth knowledge and best practices to further enhance your serverless and AI-powered applications on AWS.\n"
},
{
	"uri": "//localhost:1313/tasks/task-4-create-a-new-post-lambda-function/",
	"title": "Create a New Post Lambda Function",
	"tags": [],
	"description": "",
	"content": "Task 4: Create a New Post Lambda Function In this task, we\u0026rsquo;ll create the first Lambda function for our application. This function serves as the entry point, receiving information about new posts that need to be converted into audio files.\nWhy Lambda? AWS Lambda allows us to run code without provisioning or managing servers. It\u0026rsquo;s ideal for our use case because:\nIt\u0026rsquo;s cost-effective - we only pay for the compute time we consume. It scales automatically with the number of requests. It integrates seamlessly with other AWS services like DynamoDB and SNS. Steps to Create the Lambda Function: Access Lambda in AWS Console\nOpen the AWS Management Console In the search bar at the top, search for and choose \u0026ldquo;Lambda\u0026rdquo; Create a New Function\nClick \u0026ldquo;Create function\u0026rdquo; Choose \u0026ldquo;Author from scratch\u0026rdquo; Configure the following settings: Function name: PostReader_NewPost Runtime: Python 3.12 Execution role: Use an existing role Existing role: Choose Lab-Lambda-Role Click \u0026ldquo;Create function\u0026rdquo; Add Function Code\nIn the Function code section, delete the existing code Paste the following Python code: import boto3 import os import uuid def lambda_handler(event, context): recordId = str(uuid.uuid4()) voice = event[\u0026#34;voice\u0026#34;] text = event[\u0026#34;text\u0026#34;] print(\u0026#39;Generating new DynamoDB record, with ID: \u0026#39; + recordId) print(\u0026#39;Input Text: \u0026#39; + text) print(\u0026#39;Selected voice: \u0026#39; + voice) # Creating new record in DynamoDB table dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(os.environ[\u0026#39;DB_TABLE_NAME\u0026#39;]) table.put_item( Item={ \u0026#39;id\u0026#39; : recordId, \u0026#39;text\u0026#39; : text, \u0026#39;voice\u0026#39; : voice, \u0026#39;status\u0026#39; : \u0026#39;PROCESSING\u0026#39; } ) # Sending notification about new post to SNS client = boto3.client(\u0026#39;sns\u0026#39;) client.publish( TopicArn = os.environ[\u0026#39;SNS_TOPIC\u0026#39;], Message = recordId ) return recordId Examine the Code The Lambda function performs the following tasks:\nRetrieves two input parameters: Voice: One of dozens of voices supported by Amazon Polly Text: The content of the post to be converted into an audio file Creates a new record in the DynamoDB table with information about the new post Publishes information about the new post to SNS (the post ID is published as a message) Returns the ID of the DynamoDB item to the user Deploy the Function\nClick \u0026ldquo;Deploy\u0026rdquo; to save your changes Configure Environment Variables\nNavigate to the \u0026ldquo;Configuration\u0026rdquo; tab In the left navigation pane, choose \u0026ldquo;Environment variables\u0026rdquo; Click \u0026ldquo;Edit\u0026rdquo; and add the following variables: Key: SNS_TOPIC, Value: [Paste your SNS topic ARN] Key: DB_TABLE_NAME, Value: posts Click \u0026ldquo;Save\u0026rdquo; Update Function Configuration\nIn the left navigation pane of the Configuration tab, choose \u0026ldquo;General configuration\u0026rdquo; Click \u0026ldquo;Edit\u0026rdquo; Update the Timeout to 10 seconds Click \u0026ldquo;Save\u0026rdquo; Testing the Lambda Function Create a Test Event\nNavigate to the \u0026ldquo;Test\u0026rdquo; tab Configure a new test event with the following details: Event name: Joanna Event JSON: { \u0026#34;voice\u0026#34;: \u0026#34;Joanna\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;This is working!\u0026#34; } Click \u0026ldquo;Save\u0026rdquo; Run the Test\nClick \u0026ldquo;Test\u0026rdquo; to execute your test event You should see a \u0026ldquo;Execution result: succeeded\u0026rdquo; message Expand the \u0026ldquo;Details\u0026rdquo; section to view the execution log Congratulations! You\u0026rsquo;ve successfully created and tested the New Post Lambda function. This function will serve as the entry point for your application, handling new post submissions and initiating the audio conversion process.\n"
},
{
	"uri": "//localhost:1313/5.-clean-up/",
	"title": "Clean Up",
	"tags": [],
	"description": "",
	"content": "Clean Up If you participated in an AWS-hosted event, you don\u0026rsquo;t need to worry about cleaning up any resources. AWS will handle the cleanup process for you.\nHowever, if you ran this workshop in your own AWS account, it\u0026rsquo;s important to delete the CloudFormation stack to avoid any unexpected charges on your AWS bill. Follow these steps to clean up your resources:\nOpen the AWS CloudFormation Console.\nSelect the stack you created for this workshop (e.g., polly-serverless-stack).\nClick on the \u0026ldquo;Delete\u0026rdquo; button at the top of the stack details page.\nIn the confirmation dialog, click \u0026ldquo;Delete stack\u0026rdquo; to confirm the deletion.\nWait for the stack deletion process to complete. This may take a few minutes.\nOnce the stack is deleted, all associated resources will be removed from your account.\nBy following these steps, you ensure that all resources created during the workshop are properly cleaned up, preventing any unnecessary costs.\nRemember, it\u0026rsquo;s always a good practice to review your AWS account regularly and remove any unused resources to maintain a clean and cost-effective environment.\n"
},
{
	"uri": "//localhost:1313/tasks/task-5-create-a-convert-to-audio-lambda-function/",
	"title": "Create a Convert to Audio Lambda Function",
	"tags": [],
	"description": "",
	"content": "Creating a Lambda Function for Text-to-Audio Conversion In this step, we\u0026rsquo;ll create a Lambda function that converts text stored in a DynamoDB table into an audio file. This function will be a crucial component in our serverless text-to-speech application.\nSteps to Create the Lambda Function Navigate to Lambda Functions\nIn the AWS Management Console, go to the Lambda service. In the left navigation pane, select \u0026ldquo;Functions\u0026rdquo;. Note: If the navigation pane is collapsed, click the menu icon to expand it. Initiate Function Creation\nClick the \u0026ldquo;Create function\u0026rdquo; button. Configure Function Settings\nChoose \u0026ldquo;Author from scratch\u0026rdquo; for a custom implementation. Use the following configuration: Function name: ConvertToAudio Runtime: Python 3.12 Execution role: Expand \u0026ldquo;Change default execution role\u0026rdquo; Select \u0026ldquo;Use an existing role\u0026rdquo; Choose \u0026ldquo;Lab-Lambda-Role\u0026rdquo; from the dropdown Create the Function\nScroll to the bottom of the page and click \u0026ldquo;Create function\u0026rdquo;. Implement the Function Code\nIn the \u0026ldquo;Function code\u0026rdquo; section, you\u0026rsquo;ll see a code editor. Delete any existing code in the editor. Copy and paste the provided Python code (shown below) into the editor. Function Code Overview The Lambda function you\u0026rsquo;re about to create will:\nRetrieve text content from DynamoDB based on a given post ID. Split the text into manageable chunks (if necessary). Use Amazon Polly to convert each chunk of text into speech. Store the resulting audio files in an S3 bucket. This function is designed to handle long-form content by breaking it into smaller pieces, ensuring that even large articles can be converted to audio efficiently.\nNow, let\u0026rsquo;s implement the core functionality of our ConvertToAudio Lambda function:\nimport boto3 import os from contextlib import closing from boto3.dynamodb.conditions import Key, Attr def lambda_handler(event, context): postId = event[\u0026#34;Records\u0026#34;][0][\u0026#34;Sns\u0026#34;][\u0026#34;Message\u0026#34;] print (\u0026#34;Text to Speech function. Post ID in DynamoDB: \u0026#34; + postId) # Retrieving information about the post from DynamoDB table dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(os.environ[\u0026#39;DB_TABLE_NAME\u0026#39;]) postItem = table.query( KeyConditionExpression=Key(\u0026#39;id\u0026#39;).eq(postId) ) text = postItem[\u0026#34;Items\u0026#34;][0][\u0026#34;text\u0026#34;] voice = postItem[\u0026#34;Items\u0026#34;][0][\u0026#34;voice\u0026#34;] rest = text # Because single invocation of the polly synthesize_speech api can # transform text with about 3000 characters, we are dividing the # post into blocks of approximately 2500 characters. textBlocks = [] while (len(rest) \u0026gt; 2600): begin = 0 end = rest.find(\u0026#34;.\u0026#34;, 2500) if (end == -1): end = rest.find(\u0026#34; \u0026#34;, 2500) textBlock = rest[begin:end] rest = rest[end:] textBlocks.append(textBlock) textBlocks.append(rest) # For each block, invoke Polly API, which transforms text into audio polly = boto3.client(\u0026#39;polly\u0026#39;) for textBlock in textBlocks: response = polly.synthesize_speech( OutputFormat=\u0026#39;mp3\u0026#39;, Text = textBlock, VoiceId = voice ) # Save the audio stream returned by Amazon Polly on Lambda\u0026#39;s temp # directory. If there are multiple text blocks, the audio stream # is combined into a single file. if \u0026#34;AudioStream\u0026#34; in response: with closing(response[\u0026#34;AudioStream\u0026#34;]) as stream: output = os.path.join(\u0026#34;/tmp/\u0026#34;, postId) if os.path.isfile(output): mode = \u0026#34;ab\u0026#34; # Append binary mode else: mode = \u0026#34;wb\u0026#34; # Write binary mode (create a new file) with open(output, mode) as file: file.write(stream.read()) s3 = boto3.client(\u0026#39;s3\u0026#39;) s3.upload_file(\u0026#39;/tmp/\u0026#39; + postId, os.environ[\u0026#39;BUCKET_NAME\u0026#39;], postId + \u0026#34;.mp3\u0026#34;) s3.put_object_acl(ACL=\u0026#39;public-read\u0026#39;, Bucket=os.environ[\u0026#39;BUCKET_NAME\u0026#39;], Key= postId + \u0026#34;.mp3\u0026#34;) location = s3.get_bucket_location(Bucket=os.environ[\u0026#39;BUCKET_NAME\u0026#39;]) region = location[\u0026#39;LocationConstraint\u0026#39;] if region is None: url_beginning = \u0026#34;https://s3.amazonaws.com/\u0026#34; else: url_beginning = \u0026#34;https://s3-\u0026#34; + str(region) + \u0026#34;.amazonaws.com/\u0026#34; url = url_beginning \\ + str(os.environ[\u0026#39;BUCKET_NAME\u0026#39;]) \\ + \u0026#34;/\u0026#34; \\ + str(postId) \\ + \u0026#34;.mp3\u0026#34; # Updating the item in DynamoDB response = table.update_item( Key={\u0026#39;id\u0026#39;:postId}, UpdateExpression= \u0026#34;SET #statusAtt = :statusValue, #urlAtt = :urlValue\u0026#34;, ExpressionAttributeValues= {\u0026#39;:statusValue\u0026#39;: \u0026#39;UPDATED\u0026#39;, \u0026#39;:urlValue\u0026#39;: url}, ExpressionAttributeNames= {\u0026#39;#statusAtt\u0026#39;: \u0026#39;status\u0026#39;, \u0026#39;#urlAtt\u0026#39;: \u0026#39;url\u0026#39;}, ) return Configuring the Lambda Function After deploying the Lambda function, you need to configure several important settings:\nSetting Environment Variables Select the Configuration tab\nIn the left navigation pane, choose Environment variables\nIn the Environment variables section, click Edit\nAdd the following environment variables:\nKey Value DB_TABLE_NAME posts BUCKET_NAME [Your S3 bucket name, e.g., audioposts-123] Click Save\nAdjusting Maximum Execution Time In the General configuration section, click Edit Update the Timeout to 5 minutes Click Save Configuring SNS Trigger In the Triggers section, click Add trigger Configure as follows: Select a source: SNS SNS topic: Choose new_posts from the available topics Click Add Testing You are now ready to test if the two Lambda functions communicate successfully via SNS and create a Polly audio file.\nTask Complete You can now proceed to the next task.\n"
},
{
	"uri": "//localhost:1313/tasks/task-6-test-the-functions/",
	"title": "Test the Functions",
	"tags": [],
	"description": "",
	"content": "Task 6: Test the Functions In this crucial task, we\u0026rsquo;ll verify the functionality of our serverless blog-to-audio conversion system. We\u0026rsquo;ll test the entire workflow, from triggering the initial Lambda function to confirming the creation of the audio file in S3.\nWorkflow Overview Manually trigger the New Post Lambda function Function stores data in DynamoDB and sends a message to the SNS topic SNS triggers the Convert To Audio function Convert To Audio function uses Amazon Polly to create an audio file Audio file is stored in the S3 bucket Step-by-Step Testing Process 1. Trigger the New Post Lambda Function Navigate to the AWS Lambda console Locate and select the PostReader_NewPost function Click the \u0026ldquo;Test\u0026rdquo; button Verify the success message: \u0026ldquo;Execution result: succeeded\u0026rdquo; 2. Confirm DynamoDB Entry Open the AWS DynamoDB console In the navigation pane, choose \u0026ldquo;Explore items\u0026rdquo; Select the \u0026ldquo;posts\u0026rdquo; table Verify the presence of two entries (due to running the test twice) Note the url field in the second entry, indicating successful audio conversion 3. Check Convert to Audio Function Execution Return to the AWS Lambda console Select the ConvertToAudio function Navigate to the \u0026ldquo;Monitor\u0026rdquo; tab Examine the monitoring charts for function invocation ‚ö†Ô∏è Warning: If you encounter errors:\nCheck the \u0026ldquo;Error count and success rate\u0026rdquo; chart View CloudWatch logs for detailed error messages Common issues: Incorrect S3 bucket name in environment variables 4. Verify Audio File in S3 Open the AWS S3 console Locate and select your audioposts- bucket Confirm the presence of an MP3 file Download and play the file - you should hear Polly\u0026rsquo;s Joanna voice saying \u0026ldquo;This is working!\u0026rdquo; Troubleshooting Tips Double-check all IAM permissions Ensure SNS topic and subscription are correctly configured Verify environment variables in Lambda functions Review CloudWatch logs for detailed error information Next Steps Congratulations on successfully testing your serverless blog-to-audio conversion system! In the next task, we\u0026rsquo;ll explore ways to enhance and optimize your application.\nüéâ Task Complete! You\u0026rsquo;ve verified the core functionality of your serverless application. Proceed to the next exciting challenge in your AWS journey!\n"
},
{
	"uri": "//localhost:1313/tasks/task-7-create-a-get-post-lambda-function/",
	"title": "Create a Get Post Lambda Function",
	"tags": [],
	"description": "",
	"content": "Task 7: Create a Get Post Lambda Function In this task, we\u0026rsquo;ll create the final Lambda function that provides a method for retrieving information about posts from our DynamoDB database. This function plays a crucial role in our serverless blog-to-audio system by enabling efficient data retrieval.\nCreating the Lambda Function Navigate to the AWS Management Console In the search bar at the top, type \u0026ldquo;Lambda\u0026rdquo; and select it Click on \u0026ldquo;Create function\u0026rdquo; Choose \u0026ldquo;Author from scratch\u0026rdquo; and use these settings: Function name: PostReader_GetPost Runtime: Python 3.12 Execution role: Use an existing role Existing role: Lab-Lambda-Role Scroll down and click \u0026ldquo;Create function\u0026rdquo; Adding the Function Code Replace the existing code in the Lambda function with the following:\nimport boto3 import os from boto3.dynamodb.conditions import Key, Attr def lambda_handler(event, context): postId = event[\u0026#34;postId\u0026#34;] dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(os.environ[\u0026#39;DB_TABLE_NAME\u0026#39;]) if postId==\u0026#34;*\u0026#34;: items = table.scan() else: items = table.query( KeyConditionExpression=Key(\u0026#39;id\u0026#39;).eq(postId) ) return items[\u0026#34;Items\u0026#34;] This function is very short. It expects to get the post ID (the DynamoDB item ID) and, based on this ID, it retrieves all information (including the S3 link to the audio file if it exists) and then returns it. To make it a little more user-friendly, if the input parameter is an asterisk (*), the Lambda function returns all items from the database. For a database with a lot of items, avoid this approach because it can degrade performance and might take a long time.\nDeploy Choose Deploy.\nYou need to provide the name of the DynamoDB table as an environment variable for the function.\nConfiguring Environment Variables Choose the Configuration tab to configure the environment variables. In the left navigation pane, choose Environment variables. In the Environment variables section, choose Edit. Choose Add environment variable. Key: Enter DB_TABLE_NAME Value: Enter posts Choose Save. Testing the Function In the Test tab, create your test event using the following parameters: Event name: AllPosts Command: Replace the existing code with the following code: { \u0026#34;postId\u0026#34;: \u0026#34;*\u0026#34; } Choose Save. Choose Test to run the test event. You should see the message: Execution result: succeeded.\nIf you expand the Details section, you should see a list of all records from the DynamoDB table.\nTask Complete You can now proceed to the next task.\n"
},
{
	"uri": "//localhost:1313/tasks/task-8-expose-the-lambda-function-as-a-restful-web-service/",
	"title": "Expose the Lambda Function as a RESTful Web Service",
	"tags": [],
	"description": "",
	"content": "Task 8: Expose the Lambda Function as a RESTful Web Service In this crucial task, we\u0026rsquo;ll leverage Amazon API Gateway to expose our Lambda functions as a RESTful web service. This enables easy invocation of our application logic using standard HTTP protocols, enhancing accessibility and integration capabilities.\nCreating the API Gateway Navigate to the AWS Management Console In the search bar, type \u0026ldquo;API Gateway\u0026rdquo; and select it In the REST API panel, click \u0026ldquo;Build\u0026rdquo; Configure the API details: Choose \u0026ldquo;New API\u0026rdquo; API name: PostReaderAPI Description: API for PostReader Application Endpoint Type: Regional Click \u0026ldquo;Create API\u0026rdquo; Configuring HTTP Methods POST Method In the Resources pane, select the root (/) resource Click \u0026ldquo;Create Method\u0026rdquo; and choose POST Set up the Lambda Function: Lambda Function: Select the function containing PostReader_NewPost Click \u0026ldquo;Create Method\u0026rdquo; GET Method In the Resources pane, select the root (/) resource Click \u0026ldquo;Create Method\u0026rdquo; and choose GET Set up the Lambda Function: Lambda Function: Select the function containing PostReader_GetPost Click \u0026ldquo;Create Method\u0026rdquo; Enabling CORS Cross-Origin Resource Sharing (CORS) allows invoking the API from different hostnames:\nSelect the root (/) resource Click \u0026ldquo;Enable CORS\u0026rdquo; Configure CORS settings: Gateway responses: Select \u0026ldquo;Default 4XX\u0026rdquo; and \u0026ldquo;Default 5XX\u0026rdquo; Access-Control-Allow-Methods: Select GET and POST Click \u0026ldquo;Save\u0026rdquo; Configuring Query Parameters For the GET method:\nSelect the GET method In Method Request settings, click \u0026ldquo;Edit\u0026rdquo; Expand \u0026ldquo;URL Query String Parameters\u0026rdquo; Add a query string: Name: postId Click \u0026ldquo;Save\u0026rdquo; Setting Up Request Mapping To ensure proper JSON formatting:\nSelect the GET method Go to the \u0026ldquo;Integration Request\u0026rdquo; tab Edit the settings: Request body passthrough: \u0026ldquo;When there are no templates defined (recommended)\u0026rdquo; Expand \u0026ldquo;Mapping Templates\u0026rdquo; Add a mapping template: Content-Type: application/json Template body: { \u0026#34;postId\u0026#34;: \u0026#34;$input.params(\u0026#39;postId\u0026#39;)\u0026#34; } Click \u0026ldquo;Save\u0026rdquo; Deploying the API Click \u0026ldquo;Deploy API\u0026rdquo; Create a new stage: Stage name: Dev Click \u0026ldquo;Deploy\u0026rdquo; Copy the \u0026ldquo;Invoke URL\u0026rdquo; and save it for future use üéâ Congratulations! You\u0026rsquo;ve successfully exposed your Lambda functions as a RESTful web service using Amazon API Gateway. This powerful integration allows for seamless communication between your serverless backend and various front-end applications or services.\nNext Steps Test your API endpoints using tools like Postman or cURL Implement proper security measures, such as API keys or AWS Cognito integration Consider setting up API usage plans and throttling to manage traffic By completing this task, you\u0026rsquo;ve added a crucial layer of accessibility to your serverless blog-to-audio application, paving the way for robust and scalable client interactions.\n"
},
{
	"uri": "//localhost:1313/tasks/task-9-create-a-serverless-user-interface/",
	"title": "Create a Serverless User Interface",
	"tags": [],
	"description": "",
	"content": "Task 9: Create a Serverless User Interface Although the application is fully operational, it is only exposed as a RESTful web service. You now deploy a small web page on Amazon S3, which is a great choice for hosting static web pages. This web page uses JavaScript to connect to the API and provide text-to-speech functionalities in a web page.\nDownload these files to your computer, use mouse right click and \u0026ldquo;Save Link As\u0026hellip;\u0026rdquo;.\nindex.html scripts.js styles.css Note: Ensure that each file keeps the same filename, including the extension.\nEdit your scripts.js file with a Text Editor, replacing YOUR_API_GATEWAY_ENDPOINT (on the first line) with the Invoke URL you copied earlier.\nExpected output:\nvar API_ENDPOINT = \u0026#34;https://xxxxx.execute-api.us-west-2.amazonaws.com/Dev\u0026#34; You now upload these files to an Amazon S3 bucket.\nAt the top of the AWS Management Console, in the search bar, search for and choose S3. Choose Create bucket and configure the following details: Bucket name: www-BUCKET Replace BUCKET with the name of your audioposts bucket Copy the name of your bucket to your text editor. You use the bucket name later. You change the bucket\u0026rsquo;s permissions so that the website is accessible to everybody. Under Object Ownership, choose ACLs enabled Under Block Public Access settings for this bucket deselect the Block all public access option, and then leave all other options deselected. Note: Notice all of the individual options remain deselected. When deselecting all public access, you must then select the individual options that apply to your situation and security objectives. In a production environment, it is recommended to use the least permissive settings possible.\nA warning box appears saying that: Turning off block all public access might result in this bucket and the objects within becoming public. AWS recommends that you turn on block all public access, unless public access is required for specific and verified use cases such as static website hosting.\nSelect the check box next to I acknowledge that the current settings might result in this bucket and the objects within becoming public. Choose Create bucket After the bucket has been created, select it from the bucket list and upload the three files to your new www bucket. Note: The files must be named: index.html, scripts.js and styles.css\nOn the bucket page, select the Permissions tab at the top.\nScroll down to the Bucket Policy section and choose the Edit button.\nPaste this policy into the editor:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;PublicReadGetObject\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:s3:::www-BUCKET/*\u0026#34; ] } ] } Replace www-BUCKET with the name of your www-audioposts bucket.\nChoose Save changes.\nWARNING: If you receive an error that Policy has invalid resource, confirm that you have edited the Resource line to match the name of your bucket.\nNote: You can ignore the warning that This bucket has public access. This is intentional.\nFinally, you activate static website hosting, which makes the bucket operate like a static website.\nChoose the Properties tab. Ignore the AWS CloudTrail Permission error. Scroll down to the Static website hosting section and choose Edit. Choose Enable for Static website hosting. Index document: index.html Error document: index.html Note: For now we are using the index.html file as error document. Choose Save changes. Copy the Endpoint URL to your clipboard. And that\u0026rsquo;s it! You can now check if the website is working.\nOpen a new web browser tab and paste the Endpoint URL that you just copied.\nYou should see a page that looks like this: If you write something in the text area and choose Say it, the event is sent to your application. The application asynchronously converts the text into an audio file. Depending on the size of the text you provide, it can take a couple of seconds or a couple of minutes to convert it to an audio file.\nTo view the posts and their audio files, type the post ID or * in the Search box: Play button to hear the audio.\nTask Complete\nYou can now proceed to next task.\n"
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]